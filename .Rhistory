print(acp_princomp)
acp_princomp$scores #coord de ind sur les axes principaux
plot(individuals_coordinates)
plot(individuals_coordinates, xlab = "dim 1", ylab = "dim2")
plot(acp_prcomp$x)
plot(individuals_coordinates, xlab = "dim 1", ylab = "dim2", ylim=c(-1,1))
abline(h=0,v=0, lty=2)
par(mfrow=c(1,3))
plot(individuals_coordinates, xlab = "dim 1", ylab = "dim2", ylim=c(-1,1))
abline(h=0,v=0, lty=2)
# ACP avec prcomp
acp_prcomp <- prcomp(data, center = TRUE, scale. = TRUE)
summary(acp_prcomp)  # Affiche un résumé
print(acp_prcomp)
acp_prcomp$x #coord de ind sur les axes principaux
plot(acp_prcomp$x, xlab = "dim 1", ylab = "dim2", ylim=c(-1,1))
abline(h=0,v=0, lty=2)
# ACP avec princomp
acp_princomp <- princomp(data, cor = TRUE)
summary(acp_princomp)  # Affiche un résumé
print(acp_princomp)
acp_princomp$scores #coord de ind sur les axes principaux
plot(acp_princomp$scores, xlab = "dim 1", ylab = "dim2", ylim=c(-1,1))
abline(h=0,v=0, lty=2)
layout(matrix(1,3),3, respect=TRUE)
plot(individuals_coordinates, xlab = "dim 1", ylab = "dim2", ylim=c(-1,1))
abline(h=0,v=0, lty=2)
# ACP avec prcomp
acp_prcomp <- prcomp(data, center = TRUE, scale. = TRUE)
summary(acp_prcomp)  # Affiche un résumé
print(acp_prcomp)
acp_prcomp$x #coord de ind sur les axes principaux
plot(acp_prcomp$x, xlab = "dim 1", ylab = "dim2", ylim=c(-1,1))
abline(h=0,v=0, lty=2)
layout(matrix(1:3,3), respect=TRUE)
plot(individuals_coordinates, xlab = "dim 1", ylab = "dim2", ylim=c(-1,1))
abline(h=0,v=0, lty=2)
# ACP avec prcomp
acp_prcomp <- prcomp(data, center = TRUE, scale. = TRUE)
summary(acp_prcomp)  # Affiche un résumé
print(acp_prcomp)
acp_prcomp$x #coord de ind sur les axes principaux
plot(acp_prcomp$x, xlab = "dim 1", ylab = "dim2", ylim=c(-1,1))
abline(h=0,v=0, lty=2)
# ACP avec princomp
acp_princomp <- princomp(data, cor = TRUE)
summary(acp_princomp)  # Affiche un résumé
print(acp_princomp)
acp_princomp$scores #coord de ind sur les axes principaux
plot(acp_princomp$scores, xlab = "dim 1", ylab = "dim2", ylim=c(-1,1))
abline(h=0,v=0, lty=2)
layout(matrix(1:3,1), respect=TRUE)
plot(individuals_coordinates, xlab = "dim 1", ylab = "dim2", ylim=c(-1,1))
abline(h=0,v=0, lty=2)
# ACP avec prcomp
acp_prcomp <- prcomp(data, center = TRUE, scale. = TRUE)
summary(acp_prcomp)  # Affiche un résumé
print(acp_prcomp)
acp_prcomp$x #coord de ind sur les axes principaux
plot(acp_prcomp$x, xlab = "dim 1", ylab = "dim2", ylim=c(-1,1))
abline(h=0,v=0, lty=2)
# ACP avec princomp
acp_princomp <- princomp(data, cor = TRUE)
summary(acp_princomp)  # Affiche un résumé
print(acp_princomp)
acp_princomp$scores #coord de ind sur les axes principaux
plot(acp_princomp$scores, xlab = "dim 1", ylab = "dim2", ylim=c(-1,1))
abline(h=0,v=0, lty=2)
par(mfrow=c(1,3))
layout(matrix(1:3,1), respect=TRUE)
plot(individuals_coordinates, xlab = "dim 1", ylab = "dim2", ylim=c(-1,1), main="ACP à la main")
abline(h=0,v=0, lty=2)
# ACP avec prcomp
acp_prcomp <- prcomp(data, center = TRUE, scale. = TRUE)
summary(acp_prcomp)  # Affiche un résumé
print(acp_prcomp)
acp_prcomp$x #coord de ind sur les axes principaux
plot(acp_prcomp$x, xlab = "dim 1", ylab = "dim2", ylim=c(-1,1), main="ACP avec prcomp")
abline(h=0,v=0, lty=2)
# ACP avec princomp
acp_princomp <- princomp(data, cor = TRUE)
summary(acp_princomp)  # Affiche un résumé
print(acp_princomp)
acp_princomp$scores #coord de ind sur les axes principaux
plot(acp_princomp$scores, xlab = "dim 1", ylab = "dim2", ylim=c(-1,1), main = "ACP avec princomp")
abline(h=0,v=0, lty=2)
layout(1, respect = TRUE)
print(acp_prcomp)
r
summary(acp_prcomp)  # Affiche un résumé
xatble(summary(acp_prcomp))
xtable(summary(acp_prcomp))
print(acp_prcomp)
acp_prcomp$rotation
xtable(acp_prcomp$rotation)
# ACP avec princomp
acp_princomp <- princomp(data, cor = TRUE)
summary(acp_princomp)  # Affiche un résumé
print(acp_princomp)
acp_princomp$scores #coord de ind sur les axes principaux
plot(acp_princomp$scores, xlab = "dim 1", ylab = "dim2", ylim=c(-1,1), main = "ACP avec princomp")
acp_princomp$loadings
library("FactoMineR")
library(factoextra)
ACP_fcto <- PCA(data, scale.unit = TRUE, graph = FALSE)
print(ACP_fcto)
summary(ACP_fcto)
ACP_fcto$eig
ACP_fcto$ind$coord
ACP_fcto$var$coord
ACP_fcto$svd$V
fviz_pca_ind(ACP_fcto)
fviz_pca_var(ACP_fcto)
, palette =
fviz_pca_ind(ACP_fcto, addEllipses = TRUE)
ACP_fcto$ind
fviz_cos2(ACP_fcto, choice = "ind")
fviz_pca_ind (ACP_fcto, col.ind = "cos2",
gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07"),
repel = TRUE)
fviz_cos2(ACP_fcto, choice = "ind")
fviz_cos2(ACP_fcto, choice = "var")
fviz_contrib(ACP_fcto, choice = "ind")
#cos2 et contrib
layout(matrix(1:2, 1), respect = TRUE)
fviz_cos2(ACP_fcto, choice = "ind")
fviz_cos2(ACP_fcto, choice = "ind", axes = 2)
#cos2 et contrib
layout(matrix(1:2, 2), respect = TRUE)
fviz_cos2(ACP_fcto, choice = "ind")
fviz_cos2(ACP_fcto, choice = "ind", axes = 2)
#cos2 et contrib
layout(matrix(1:2,2), respect = TRUE)
fviz_cos2(ACP_fcto, choice = "ind")
#cos2 et contrib
layout(matrix(1:2,1), respect = TRUE)
fviz_cos2(ACP_fcto, choice = "ind")
#cos2 et contrib
layout(matrix(1:2,2), respect = TRUE)
fviz_cos2(ACP_fcto, choice = "ind")
fviz_cos2(ACP_fcto, choice = "ind", axes = 2)
#cos2 et contrib
layout(matrix(1:2, 1), respect=TRUE)
fviz_cos2(ACP_fcto, choice = "ind")
fviz_cos2(ACP_fcto, choice = "ind", axes = 2)
#cos2 et contrib
layout(matrix(1:2, 1))
fviz_cos2(ACP_fcto, choice = "ind")
fviz_cos2(ACP_fcto, choice = "ind", axes = 2)
#cos2 et contrib
par(mfrow=c(1,2))
fviz_cos2(ACP_fcto, choice = "ind")
fviz_cos2(ACP_fcto, choice = "ind", axes = 2)
install.packages("gridExtra")
#cos2 et contrib
library(gridExtra)
#cos2 et contrib
library(gridExtra)
coska1 <- fviz_cos2(ACP_fcto, choice = "ind")
coska2 <- fviz_cos2(ACP_fcto, choice = "ind", axes = 2)
grid.arrange(coska1, coska2, ncol = 2)
fviz_contrib(ACP_fcto, choice = "ind", axes=2)
grid.arrange(contrib1, contrib2, ncol = 2)
contrib1 <- fviz_contrib(ACP_fcto, choice = "ind")
contrib2 <- fviz_contrib(ACP_fcto, choice = "ind", axes=2)
grid.arrange(contrib1, contrib2, ncol = 2)
fviz_contrib(ACP_fcto, choice = "var")
#Cercle de correlation
fviz_pca_var(ACP_fcto)
#####Exercice 24:#####
Station <- read.csv("~/Desktop/TP_M1MIASHS_SSD_AD/post-197357-stations.txt", sep="")
sta <- Station [,-1]
library(FactoMineR)
library(factoextra)
acp.station<- PCA(sta,scale.unit = TRUE, graph= TRUE)
acp.station$eig
fviz_eig(acp.station, addlabels = TRUE, ylim= c(0,60))
#on prend le 3 premiere dimensions car >1, regle du coude, cum de var est 88,23%
#ersoum l moyenne?
names(acp.station)
names(acp.station$ind)
setwd("~/ProjectsM1/CoursStatInf")
setwd("~/ProjectsM1/CoursTeststat/TP2")
data <- read.csv("ozone (1).csv", sep = ";", dec = ",",
header = TRUE)
attach(data)
#température observée
par(mfrow=c(1,3))
boxplot(T9, data=data, ylim=c(10,37), main= "Boxplot de T9")
boxplot(T12, data=data, ylim=c(10,37), main= "Boxplot de T12")
boxplot(T15, data=data, ylim=c(10,37), main= "Boxplot de T15")
par(mfrow=c(1,1))
View(data)
pairwise.t.test(maxO3, vent)
avec_pluie <- maxO3[pluie=="Pluie"]
sans_pluie <- maxO3[pluie=="Sec"]
#test de normalite
shapiro.test(avec_pluie)
shapiro.test(sans_pluie)
#var test
var.test(avec_pluie,sans_pluie)
#t-test
t.test(avec_pluie,sans_pluie)
#2
boxplot(maxO3~pluie)
#test non parametrique
wilcox.test(avec_pluie,sans_pluie)
#3
#test parametrique
nord <- maxO3[vent=="Nord"]
est <- maxO3[vent=="Est"]
sud <- maxO3[vent=="Sud"]
ouest <- maxO3[vent=="Ouest"]
boxplot(maxO3~vent)
lm(maxO3~vent)
summary(lm(maxO3~vent))
plot(lm(maxO3~vent))
boxplot(maxO3~vent)
#test non parametrique
kruskal.test(maxO3~vent)
#les p-valeurs pour ventNord et ventSud sont grades yaaen on rejette H0
pairwise.t.test(maxO3,vent)
shapiro.test(nord)
shapiro.test(est)
shapiro.test(sud)
shapiro.test(nord)
shapiro.test(est)
shapiro.test(sud)
shapiro.test(ouest)
#test de normalite
shapiro.test(avec_pluie)
length((nord))
length((est))
length(sud)
length(ouest)
#4
lm(maxO3~T9+T12+T15)
#4
cor.test(maxO3,T9+T12+T15)
avec_pluie <- maxO3[pluie=="Pluie"]
sans_pluie <- maxO3[pluie=="Sec"]
#test de normalite
shapiro.test(avec_pluie)
shapiro.test(sans_pluie)
length(nord) echantillon petit
length(nord) #echantillon petit
length(ouest) # echantillon petit
#elles ne sont pas normales
length(avec_pluie)
length(sans_pluie)
#var test
var.test(avec_pluie,sans_pluie)
#var test
var.test(avec_pluie,sans_pluie)
#t-test
t.test(avec_pluie,sans_pluie, var.equal = FALSE)
lm(maxO3~T9+T12+T15)
summary(m)
m <- lm(maxO3~T9+T12+T15)
summary(m)
#pour T9 la p-valeur est 0.89933 donc accepte cor=0 et on peut l'enlever
m <- lm(maxO3~T12+T15)
summary(m)
#pour T9 la p-valeur est 0.89933 donc accepte cor=0 et on peut l'enlever
m <- lm(maxO3~T15)
summary(m)
#pour T9 la p-valeur est 0.89933 donc accepte cor=0 et on peut l'enlever
m <- lm(maxO3~T9)
summary(m)
plot(T12+T15,maxO3)
plot(T9+T12+T15,maxO3)
plot(T12+T15,maxO3)
abline(m, col="red")
#pour T9 la p-valeur est 0.89933 donc accepte cor=0 et on peut l'enlever
m <- lm(maxO3~T12+T15)
summary(m)
plot(T12+T15,maxO3)
abline(m, col="red")
plot(T12,maxO3)
abline(m, col="red")
#pour T9 la p-valeur est 0.89933 donc accepte cor=0 et on peut l'enlever
m <- lm(maxO3~T12+T15)
m
abline(m, col="red")
#ma baaml graphes, la2ano kel l test on rejette H0 yaane manoun significatives
#4
#
library(MASS)
stepAIC(m,direction = "backward")
plot(stepAIC(m,direction = "backward"))
summary(stepAIC(m,direction = "backward"))
#nebulosite
m <- lm(maxO3~Ne9+Ne12+Ne15)
stepAIC(m,direction = "backward")
summary(stepAIC(m,direction = "backward"))
plot(Ne9+Ne12, maxO3)
plot(T12+T15, maxO3)
#nebulosite
m <- lm(maxO3~Ne9+Ne12+Ne15)
stepAIC(m,direction = "backward")
summary(stepAIC(m,direction = "backward"))
plot(Ne9+Ne12, maxO3)
#force du vent
m <- lm(maxO3~Vx9+Vx12+Vx15)
stepAIC(m,direction = "backward")
summary(stepAIC(m,direction = "backward"))
plot(Vx9, maxO3)
#5
cor.test(maxO3,maxO3v)
#nebulosite
cor.test(maxO3,Ne9)
cor.test(maxO3,Ne12)
cor.test(maxO3,Ne15)
#force du vent
cor.test(maxO3,Vx9)
cor.test(maxO3,Vx12)
cor.test(maxO3,Vx15)
lm(maxO3~maxO3v)
m <- lm(maxO3~maxO3v)
plot(maxO3v,maxO3)
abline(m, col="red")
mmod <- stepAIC(m,direction = "backward")
summary(mmod)
abline(mmod, col="red")
plot(Vx9, maxO3)
abline(mmod, col="red")
plot(Vx9, maxO3)
abline(mmod, col="red")
m <- lm(maxO3~Vx9+Vx12+Vx15)
mmod <- stepAIC(m,direction = "backward")
summary(mmod)
plot(Vx9, maxO3)
abline(mmod, col="red")
abline(mmod, col="red")
#force du vent
cor.test(maxO3,Vx9)
cor.test(maxO3,Vx12)
cor.test(maxO3,Vx15)
m <- lm(maxO3~Vx9+Vx12+Vx15)
mmod <- stepAIC(m,direction = "backward")
summary(mmod)
plot(Vx9, maxO3)
abline(mmod, col="red")
colnames(data)
#6
m <- lm(maxO3~T9+T12+T15+Ne9+Ne12+Ne15+Vx9+Vx12+Vx15+maxO3v+vent+pluie)
stepAIC(m, direction = "backward")
#6
m <- lm(maxO3~T9+T12+T15+Ne9+Ne12+Ne15+Vx9+Vx12+Vx15+maxO3v+vent+pluie)
stepAIC(m, direction = "backward")
stepAIC(m, direction = "forward")
stepAIC(m, direction = "both")
stepAIC(m, direction = "backward")
#maximum de concentration d'ozone observée sur la journée
boxplot(maxO3, data=data)
#température observée
par(mfrow=c(1,3))
boxplot(T9, data=data, ylim=c(10,37), main= "Boxplot de T9")
boxplot(T12, data=data, ylim=c(10,37), main= "Boxplot de T12")
boxplot(T15, data=data, ylim=c(10,37), main= "Boxplot de T15")
#pvaleur petite, on rejtte H0, yaane toutes les madiane sont diff
pairwise.wilcox.test(maxO3,vent)
library(ggplot)
library(ggplot2)
ggpairs(data)
ggpair(data)
library(ggplot2)
ggpairs(data)
library(GGally)
ggpairs(data)
#composante est-ouest du vent 9,12, 15
par(mfrow=c(1,3))
boxplot(Vx9, data=data, ylim=c(-9,9),main= "Boxplot de Vx9")
boxplot(Vx12, data=data, ylim=c(-9,9), main= "Boxplot de Vx12")
boxplot(Vx15, data=data, ylim=c(-9,9), main= "Boxplot de Vx15")
par(mfrow=c(1,1))
install.packages("modelsummary")
library(modelsummary)
datasummary_balance(data)
datasummary_skim(data)
setwd("~/Github/Projet_tuto")
# install.packages("sf")
# install.packages("leaflet")
# install.packages("readr")
library(sf)
library(leaflet)
################################
##"cleaning du jeu de données"##
# DataSet
data <- read.csv(file = "C:/Users/Serge C/Documents/MIASHS/ProjetTutore/Q_38_previous-1950-2022_RR-T-Vent/Q_38_previous-1950-2022_RR-T-Vent.csv", sep = ";")
################################
##"cleaning du jeu de données"##
# DataSet
data <- read.csv(file = "~/Downloads/Q_38_previous-1950-2022_RR-T-Vent.csv/Q_38_previous-1950-2022_RR-T-Vent.csv", sep = ";")
attach(data)
# Traitement de la variable année
annee <- substr(AAAAMMJJ, 1,4)
data <- cbind(annee,data)
# split en fonction des stations
data_station <- split(data, NOM_USUEL)
# Liste traitée comme un dataframe
data_station$`AIGLETON-NIVOSE`
## Boucle création jeu de donnée par station et par année :
# Intitalisation
station <- unique(NOM_USUEL)
periode <- sort(unique(annee), decreasing = FALSE)
# Première création de carte avec les données Geojson
# txtconvert <- read.csv(file = file.choose(), header = FALSE, sep = ",", dec = ".")
# txtconvert <- txtconvert[,-3]
# frontIsere <- st_as_sf(txtconvert, coords = c("V1", "V2"), crs = 4326)
# st_write(frontIsere, "isere.shp")
## Lecture des données traitées ci-dessus
dataconvert <- read.csv(file ="C:/Users/Serge C/Documents/MIASHS/ProjetTutore/dataStations.csv", header = TRUE)
# Première création de carte avec les données Geojson
# txtconvert <- read.csv(file = file.choose(), header = FALSE, sep = ",", dec = ".")
# txtconvert <- txtconvert[,-3]
# frontIsere <- st_as_sf(txtconvert, coords = c("V1", "V2"), crs = 4326)
# st_write(frontIsere, "isere.shp")
## Lecture des données traitées ci-dessus
dataconvert <- read.csv(file ="~/danielleelkhoury/Github/Projet_tuto/dataStations.csv", header = TRUE)
# Première création de carte avec les données Geojson
# txtconvert <- read.csv(file = file.choose(), header = FALSE, sep = ",", dec = ".")
# txtconvert <- txtconvert[,-3]
# frontIsere <- st_as_sf(txtconvert, coords = c("V1", "V2"), crs = 4326)
# st_write(frontIsere, "isere.shp")
## Lecture des données traitées ci-dessus
dataconvert <- read.csv(file ="~/Github/Projet_tuto/dataStations.csv", header = TRUE)
# Première création de carte avec les données Geojson
# txtconvert <- read.csv(file = file.choose(), header = FALSE, sep = ",", dec = ".")
# txtconvert <- txtconvert[,-3]
# frontIsere <- st_as_sf(txtconvert, coords = c("V1", "V2"), crs = 4326)
# st_write(frontIsere, "isere.shp")
## Lecture des données traitées ci-dessus
dataconvert <- read.csv(file ="~/Github/Projet_tuto/dataStations.csv", header = TRUE)
isere <- st_read("~/Github/Projet_tuto/isere.shp")
isere <- isere[,-1]
isere_ligne <- st_union(isere[5:380,1]) %>%
st_cast("LINESTRING")
geo_data <- st_read("~/Github/Projet_tuto/dataStations.geojson")
# Traitelent des stations qui possèdent des données
isol2 <- c(109, 14, 95, 131, 19, 47, 22, 145, 163, 108, 8, 48, 83, 21, 70, 111, 10,105, 179, 24, 68, 69, 67, 41, 20, 132, 158, 96, 97, 123, 32, 23,39,122,133,134,139,128,129,126,127,178,177,42,12,27,102,103,28,135,168,181,73,55,107,30,33,137,64,85,43,153,84,165,38,92,91,104,191,192,193,194,66,81,78,80,79,77,176,15,10,11,18,17,88,62,59,60,61,63,5,1,2,3,4,157)
nom_isol2 <- station[isol2]
isol3 <- c(109, 14, 95, 131, 19, 47, 22, 145, 163, 108, 8, 48, 83, 21, 70, 111, 10,105,  68, 67, 20, 96, 123,  23, 39, 122, 133, 139, 128, 178, 42, 12, 102, 28, 168, 181, 73, 55, 107, 30, 33, 137, 85, 153, 165, 38, 92, 91, 104, 191, 66, 81, 15, 10, 88, 62, 5, 1)
nom_isol3 <- station[isol3]
geo_data <- cbind(geo_data,rep(NA,dim(geo_data)[1]))
geo_data[,5] <- ifelse(geo_data$Station %in% nom_isol3, 1, 0)
# Programmation de la carte de l'isère avec l'ajout des stations
carte_station <- leaflet(data = geo_data[which(geo_data$rep.NA..dim.geo_data..1.. == 0),]) %>%
addTiles() %>%
addCircleMarkers(
data = isere,
radius = 0.1,
color = "black",
stroke = TRUE,
fillOpacity = 0.7
) %>%
addPolylines(
data = isere_ligne,
color = "black",
weight = 2,
opacity = 0.8
) %>%
addCircleMarkers(
radius = 5,
color = "blue",
stroke = FALSE,
fillOpacity = 0.7,
popup = ~Station
) %>%
addCircleMarkers(
data = geo_data[which(geo_data$rep.NA..dim.geo_data..1.. == 1),],
radius = 5,
color = "red",
stroke = FALSE,
fillOpacity = 0.7,
popup = ~Station
) %>%
setView(lng = mean(dataconvert$Long), lat = mean(dataconvert$Lat), zoom = 10)
carte_station
# Programmation de la carte de l'isère avec l'ajout des stations
carte_station <- leaflet(data = geo_data[which(geo_data$rep.NA..dim.geo_data..1.. == 0),]) %>%
addTiles() %>%
addCircleMarkers(
data = isere,
radius = 0.1,
color = "black",
stroke = TRUE,
fillOpacity = 0.7
) %>%
# #addPolylines(
#   #data = isere_ligne,
#   color = "black",
#   weight = 2,
#   opacity = 0.8
# ) %>%
addCircleMarkers(
radius = 5,
color = "blue",
stroke = FALSE,
fillOpacity = 0.7,
popup = ~Station
) %>%
addCircleMarkers(
data = geo_data[which(geo_data$rep.NA..dim.geo_data..1.. == 1),],
radius = 5,
color = "red",
stroke = FALSE,
fillOpacity = 0.7,
popup = ~Station
) %>%
setView(lng = mean(dataconvert$Long), lat = mean(dataconvert$Lat), zoom = 10)
carte_station
